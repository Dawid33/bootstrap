; initialize global_variables_end
C=:global_variables_end
D=:global_variables
8C=D
; initialize static_memory_end
C=:static_memory_end
D=x500000
8C=D
; initialize labels_end
C=:labels_end
D=:labels
8C=D

; open input file
	J=:input_filename
	I=d0
	syscall x2
	J=A
	?J<0:input_file_error
; open output file
	J=:output_filename
	I=x241
	D=x1ed
	syscall x2
	J=A
	?J<0:output_file_error

:second_pass_starting_point
; write ELF header
J=d4
I=:ELF_header
D=x78
syscall x1

:read_line
; increment line number
D=:line_number
C=8D
C+=d1
8D=C

; use rbp to store line pointer
R=:line
:read_line_loop
	; read 1 byte into rbp
	J=d3
	I=R
	D=d1
	syscall x0
	D=A
	?D=0:eof
	
	; check if the character was a newline:
	C=1R
	D=xa
	?C=D:read_line_loop_end
	; check if the character was a tab:
	D=x9
	; if so, don't increment rbp
	?C=D:read_line_loop
	; check if the character was a semicolon:
	D=';
	; if so, it's a comment
	?C=D:handle_comment
	
	R+=d1
	!:read_line_loop

	:handle_comment
		; read out rest of line from file
		J=d3
		I=R
		D=d1
		syscall x0
		D=A
		?D=0:eof
		C=1R
		D=xa
		; if we didn't reach the end of the line, keep going
		?C!D:handle_comment
		
		!:read_line_loop_end
:read_line_loop_end

; remove whitespace (specifically, ' ' characters) at end of line
I=R
:remove_terminal_whitespace_loop
	I-=d1
	C=1I
	D=x20
	?C!D:remove_terminal_whitespace_loop_end
	; replace ' ' with a newline
	D=xa
	1I=D
	!:remove_terminal_whitespace_loop
:remove_terminal_whitespace_loop_end

; check if this is a blank line
C=:line
D=1C
C=xa
?C=D:read_line

C=':
?C=D:handle_label_definition

I=:line
J=:"global"
C=x20
call :string=
D=A
?D!0:handle_global

I=:line
J=:"local"
C=x20
call :string=
D=A
?D!0:handle_local
; arguments are treated the same as local variables
I=:line
J=:"argument"
C=x20
call :string=
D=A
?D!0:handle_local

I=:line
J=:"return"
C=x20
call :string=
D=A
?D!0:handle_return

; set delimiter to newline
C=xa

I=:line
J=:"function"
call :string=
D=A
?D!0:handle_function


!:read_line

:eof
	C=:second_pass
	D=1C
	?D!0:exit_success
	; set 2nd pass to 1
	1C=d1
	; seek both files back to start
	J=d3
	I=d0
	D=d0
	syscall x8
	J=d4
	I=d0
	D=d0
	syscall x8
	
	!:second_pass_starting_point
	
:exit_success
	J=d0
	syscall x3c

align
:local_variable_name
	reserve d8
	
:handle_local
	R=I
	
	; emit sub rsp, 8
	J=d4
	I=:sub_rsp_8
	D=d7
	syscall x1
	
	I=R
	; skip ' '
	I+=d1
	
	; store away pointer to variable name
	C=:local_variable_name
	8C=I
	
	; check if already defined
	J=:local_variables
	call :ident_lookup
	C=A
	?C!0:local_redeclaration
	C=:local_variable_name
	I=8C
	
	J=:local_variables_end
	J=8J
	call :ident_copy
	; increase stack_end, store it in J
	C=:stack_end
	D=4C
	D+=d8
	4C=D
	4J=D
	J+=d4
	;  store null terminator
	1J=0
	; update :local_variables_end
	I=:local_variables_end
	8I=J
	; read the next line
	!:read_line
	
:sub_rsp_8
	x48
	x81
	xec
	x08
	x00
	x00
	x00

align
:global_start
	reserve d8
:global_variable_name
	reserve d8
:handle_global
	; ignore if this is the second pass
	C=:second_pass
	C=1C
	?C!0:read_line
	
	; skip ' '
	I+=d1
	
	; store away pointer to variable name
	C=:global_variable_name
	8C=I
	
	; check if already defined
	J=:global_variables
	call :ident_lookup
	C=A
	?C!0:global_redeclaration
	
	C=:global_variable_name
	I=8C
	
	J=:global_variables_end
	J=8J
	call :ident_copy
	; store address
	D=:static_memory_end
	C=4D
	4J=C
	J+=d4
	; increase static_memory_end
	C+=d8
	4D=C
	; store null terminator
	1J=0
	; update :global_variables_end
	I=:global_variables_end
	8I=J
	; go read the next line
	!:read_line

:handle_function
	; emit prologue
	J=d4
	I=:function_prologue
	D=d14
	syscall x1
	
	; reset local variable table
	D=:local_variables
	1D=0
	C=:local_variables_end
	8C=D
	
	; reset stack_end
	D=:stack_end
	4D=0
	
	; go read the next line
	!:read_line

:function_prologue
	; sub rsp, 8
	x48
	x81
	xec
	x08
	x00
	x00
	x00
	; mov [rsp], rbp
	x48
	x89
	x2c
	x24
	; mov rbp, rsp
	R=S
	; total length: 7 + 4 + 3 = 14 bytes

:function_epilogue
	; mov rsp, rbp
	S=R
	; mov rbp, [rsp]
	x48
	x8b
	x2c
	x24
	; add rsp, 8
	x48
	x81
	xc4
	x08
	x00
	x00
	x00
	; ret
	return
	; total length = 15 bytes

:handle_label_definition
	; ignore if this is the second pass
	C=:second_pass
	C=1C
	?C!0:read_line
	
	; make sure label only has identifier characters
	I=:line
	I+=d1
	:label_checking_loop
		C=1I
		D=xa
		?C=D:label_checking_loop_end
		I+=d1
		B=C
		call :isident
		D=A
		?D!0:label_checking_loop
		!:bad_label
	:label_checking_loop_end
	
	I=:line
	I+=d1
	J=:global_variables
	call :ident_lookup
	C=A
	?C!0:label_redefinition
	
	J=:labels_end
	J=8J
	I=:line
	I+=d1
	call :ident_copy
	R=J
	
	; figure out where in the file we are
	J=d4
	I=d0
	D=d1
	syscall x8
	C=A
	C+=x400000
	J=R
	; store address
	4J=C
	J+=d4
	
	; update labels_end
	C=:labels_end
	8C=J
	
	; read the next line
	!:read_line


:handle_return
	I=:line
	; "return " is 7 chars long
	I+=d7
	
	call :set_rax_to_term

	J=d4
	I=:function_epilogue
	D=d15
	syscall x1
	
	; go read the next line
	!:read_line	

:mov_rsp_rbp
	S=R

:ret
	return

; copy the newline-terminated identifier from rsi to rdi
:ident_copy
	C=1I
	B=C
	call :isident
	D=A
	?D=0:bad_identifier
	
	:ident_loop
		C=1I
		1J=C
		I+=d1
		J+=d1
		D=xa
		?C=D:ident_loop_end
		B=C
		call :isident
		D=A
		?D=0:bad_identifier
		!:ident_loop
	:ident_loop_end
	return

align
:ident_lookup_i
	reserve d8

; look up identifier rsi in list rdi
; returns address of whatever's right after the identifier in the list, or 0 if not found
:ident_lookup
	C=:ident_lookup_i
	8C=I
	
	:ident_lookup_loop
		; check if reached the end of the table
		C=1J
		?C=0:return_0
		I=:ident_lookup_i
		I=8I
		call :ident=
		C=A
		; move past terminator of identifier in table
		:ident_finish_loop
			D=1J
			J+=d1
			A=xa
			?D!A:ident_finish_loop
		; check if this was it
		?C!0:return_J
		; nope. keep going
		; skip over address:
		J+=d4
		!:ident_lookup_loop
		
; can the character in rbx appear in an identifier?
:isident
	A='0
	?B<A:return_0
	; note: 58 = '9' + 1
	A=d58
	?B<A:return_1
	A='A
	?B<A:return_0
	; note: 91 = 'z' + 1
	A=d91
	?B<A:return_1
	A='z
	?B>A:return_0
	; 96 = 'a' - 1
	A=d96
	?B>A:return_1
	A='_
	?B=A:return_1
	!:return_0

; set rax to the term in rsi
:set_rax_to_term
	R=I
	
	C=1I
	D=''
	?C=D:term_char
	
	C=1I
	D=d58
	?C<D:term_number
	
	; variable
	J=:local_variables
	call :ident_lookup
	C=A
	?C=0:rax2term_try_global
		; it's a local variable
		; read the offset from rbp
		D=4C
		; put negated offset in rcx
		C=d0
		C-=D
		; store negated offset in :rax2term_addr
		D=:rax2term_addr
		4D=C
		
		J=d4
		I=:load_rbp_offset_prefix
		D=d3
		syscall x1
		J=d4
		I=:rax2term_addr
		D=d4
		syscall x1
		
		return
		
	:rax2term_try_global
	J=:global_variables
	call :ident_lookup
	C=A
	?C=0:bad_term
	; it's a global variable
	; get its address
	C=4C
	D=:rax2term_addr
	4D=C
	
	; put address in rbx
	J=d4
	I=:mov_ebx_imm32_prefix
	D=d1
	syscall x1
	J=d4
	I=:rax2term_addr
	D=d4
	syscall x1
	
	; now load [rbx] into rax
	J=d4
	I=:mov_rax_[rbx]
	D=d3
	syscall x1
	
	return

:term_char
	I+=d1
	I=1I
	!:set_rax_to_immediate
	
:number_is_negative
	reserve d1

:term_number
	C=1I
	D='-
	; set rdx to 0 if number is positive, 1 if negative
	?C=D:term_number_negative
	D=d0
	!:term_number_cont
	:term_number_negative
	D=d1
	I+=d1
	:term_number_cont
	; store away negativity
	C=:number_is_negative
	1C=D
	
	C=1I
	D='0
	?C=D:term_hex_number
	; it's a decimal number
	; rbp will store the number
	R=d0
	:decimal_number_loop
		C=1I
		D='9
		?C>D:decimal_number_loop_end
		D='0
		?C<D:decimal_number_loop_end
		C-=D
		; multiply by 10
		B=d10
		A=R
		mul
		R=A
		; add this digit
		R+=C
		
		I+=d1
		!:decimal_number_loop
	:decimal_number_loop_end
	!:term_number_output
	
:term_hex_number
	I+=d1
	C=1I
	D='x
	; 0 followed by something other than x
	?C!D:bad_term
	I+=d1
	; rbp will store the number
	R=d0
	:hex_number_loop
		C=1I
		D='0
		?C<D:hex_number_loop_end
		D=d58
		?C<D:hex_number_0123456789
		D='a
		?C<D:hex_number_loop_end
		D='f
		?C>D:hex_number_loop_end
		; one of the digits a-f
		D=xffffffffffffffa9
		!:hex_number_digit
		:hex_number_0123456789
		D=xffffffffffffffd0
		:hex_number_digit
		C+=D
		; shift left by 4
		R<=d4
		; add digit
		R+=C
		I+=d1
		!:hex_number_loop
	:hex_number_loop_end
	!:term_number_output
	
:term_number_output
	; we now have the *unsigned* number in rbp. first, take the sign into consideration
	C=:number_is_negative
	D=1C
	?D=0:number_not_negative
		; R = -R
		C=R
		R=d0
		R-=C
	:number_not_negative
	I=R
	!:set_rax_to_immediate
	
	

; set <rax> to the immediate in rsi.
:set_rax_to_immediate
	C=:imm64
	8C=I
		
	; write prefix
	J=d4
	D=d2
	I=:mov_rax_imm64_prefix
	syscall x1
	
	; write immediate
	J=d4
	D=d8
	I=:imm64
	syscall x1
	return

align
:rax2term_addr
	reserve d4

:mov_ebx_imm32_prefix
	xbb

:mov_rax_imm64_prefix
	x48
	xb8

align	
:imm64
	reserve d8
:mov_rax_[rbx]
	x48
	x8b
	x03

; prefix for mov rax, [rbp+IMM32]
:load_rbp_offset_prefix
	x48
	x8b
	x85

:input_filename
	str in04b
	x0

:output_filename
	str out04b
	x0

:input_file_error
	B=:input_file_error_message
	!:general_error

:input_file_error_message
	str Couldn't open input file.
	xa
	x0

:output_file_error
	B=:output_file_error_message
	!:general_error

:output_file_error_message
	str Couldn't open output file.
	xa
	x0

:bad_identifier
	B=:bad_identifier_error_message
	!:program_error

:bad_identifier_error_message
	str Bad identifier.
	xa
	x0

:bad_label
	B=:bad_label_error_message
	!:program_error

:bad_label_error_message
	str Bad label.
	xa
	x0

:bad_term
	B=:bad_term_error_message
	!:program_error

:bad_term_error_message
	str Bad term.
	xa
	x0

:label_redefinition
	B=:label_redefinition_error_message
	!:program_error

:label_redefinition_error_message
	str Label redefinition.
	xa
	x0

:global_redeclaration
	B=:global_redeclaration_error_message
	!:program_error

:global_redeclaration_error_message
	str Global variable declared twice.
	xa
	x0

:local_redeclaration
	B=:local_redeclaration_error_message
	!:program_error

:local_redeclaration_error_message
	str Local variable declared twice.
	xa
	x0

:general_error
	call :eputs
	J=d1
	syscall x3c

:program_error
	R=B
	
	B=:"Line"
	call :eputs
	
	D=:line_number
	D=8D
	B=D
	call :eputn
	
	B=:line_number_separator
	call :eputs
	
	B=R
	call :eputs
	J=d1
	syscall x3c

:"Line"
	str Line
	x20
	x0

:line_number_separator
	str :
	x20
	x0
	
:strlen
	I=B
	D=B
	:strlen_loop
	C=1I
	?C=0:strlen_ret
	I+=d1
	!:strlen_loop
	:strlen_ret
	I-=D
	A=I
	return

; check if strings in rdi and rsi are equal, up to terminator in rcx
:string=
	D=1I
	A=1J
	?D!A:return_0
	?D=C:return_1
	I+=d1
	J+=d1
	!:string=

; check if strings in rdi and rsi are equal, up to the first non-identifier character
:ident=
	D=1I
	B=D
	call :isident
	; I ended
	?A=0:ident=_I_end
	
	D=1J
	B=D
	call :isident
	; J ended, but I didn't
	?A=0:return_0
	
	; we haven't reached the end of either
	D=1I
	A=1J
	?D!A:return_0
	I+=d1
	J+=d1
	!:ident=
:ident=_I_end
	D=1J
	B=D
	call :isident
	; check if J also ended
	?A=0:return_1
	; J didn't end
	!:return_0
	
:return_0
	A=d0
	return
:return_1
	A=d1
	return
:return_2
	A=d2
	return
:return_3
	A=d3
	return
:return_4
	A=d4
	return
:return_5
	A=d5
	return
:return_6
	A=d6
	return
:return_7
	A=d7
	return
:return_8
	A=d8
	return
:return_J
	A=J
	return
	
; write the character in rbx to the file in rdi.
:fputc
	C=B
	I=S
	I-=d1
	1I=C
	D=d1
	syscall x1
	return

; write the string in rbx to stderr
:eputs
	J=B
	call :strlen
	D=A
	I=J
	J=d2
	syscall x1
	return
	
; write rbx in decimal to stderr
:eputn
	I=B
	J=S
	J-=d1
	:eputn_loop
		D=d0
		; divide by 10
		B=d10
		A=I
		div
		; quotient is new number
		I=A
		; add remainder to string
		D+='0
		1J=D
		J-=d1
		?I!0:eputn_loop
	D=S
	D-=J
	I=J
	J=d2
	syscall x1
	return

; copy rdx bytes from rsi to rdi.
; this copies from the left: if you're doing an overlapped copy, rsi should be greater than rdi
:memcpy
	?D=0:return_0
	A=1I
	1J=A
	I+=d1
	J+=d1
	D-=d1
	!:memcpy
	
; copy from rdi to rsi, until byte cl is reached 
:memccpy
	D=1I
	1J=D
	I+=d1
	J+=d1
	?D!C:memccpy
	return

:"global"
	str global
	x20
:"argument"
	str argument
	x20
:"local"
	str local
	x20
:"return"
	str return
	x20
:"function"
	str function
	xa

; put a 0 byte before the line (this is important for removing whitespace at the end of the line,
; specifically, we don't want this to be a space character)
x0
:line
	reserve d1000
	
align
:global_variables_end
	reserve d8
:static_memory_end
	reserve d8
:local_variables_end
	reserve d8
:stack_end
	reserve d8
:labels_end
	reserve d8
:line_number
	reserve d8
:global_variables
	reserve d50000
:local_variables
	reserve d20000
:labels
	reserve d200000
:second_pass
	reserve d1

:ELF_header
x7f
x45
x4c
x46
x02
x01
x01

reserve d9

x02
x00

x3e
x00

x01
x00
x00
x00

x78
x00
x40
x00
x00
x00
x00
x00

x40
x00
x00
x00
x00
x00
x00
x00

reserve d12

x40
x00
x38
x00
x01
x00
x00
x00
x00
x00
x00
x00

x01
x00
x00
x00

x07
x00
x00
x00

x78
x00
x00
x00
x00
x00
x00
x00

x78
x00
x40
x00
x00
x00
x00
x00

reserve d8

x00
x00
x20
x00
x00
x00
x00
x00

x00
x00
x20
x00
x00
x00
x00
x00

x00
x10
x00
x00
x00
x00
x00
x00

; NOTE: we shouldn't end the file with a reserve; we don't handle that properly	

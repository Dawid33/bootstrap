; declaration:
;     global <name>
;     local <name>
;     argument <name>
;     :<label>
; statement:
;     <declaration>
;     if <term> <==/</>/>=/<=/!=> <term> goto <label>   NOTE: this uses signed comparisons
;     goto <label>
;     <lvalue> = <rvalue>
;     <lvalue> += <rvalue>
;     <lvalue> -= <rvalue>
;     <function>(<term>, <term>, ...)
;     return <rvalue>
;     string <str>
;     byte <number>
;     reserve <number>
; term:
;     <var>
;     .<label>
;     <number>
; number:
;     'c
;     12345
;     0xabc
; lvalue:
;     <var>
;     *1<var> / *2<var> / *4<var> / *8<var>
; rvalue:
;     <term>
;     &<var>
;     *1<var> / *2<var> / *4<var> / *8<var>
;     ~<term>
;     <function>(<term>, <term>, ...)
;     <term> + <term>
;     <term> - <term>
;    NOTE: *, /, % are signed (imul and idiv)
;     <term> * <term>
;     <term> / <term>
;     <term> % <term>
;     <term> & <term>
;     <term> | <term>
;     <term> ^ <term>
;     <term> < <term>  (left shift)
;     <term> > <term>  (unsigned right shift)

main() ; hello

global x
global y ;123
global z
:test
function
	local eee
	local fff
	local ggg
	return *2fff
:test2
function
	return -123
	
:syscall
function
	; ...
	byte 0x0f
	byte 0x05

:strlen
function
	argument s
	local len
	local c
	local p
	len = 0
	:strlen_loop
	p = s + len
	c = *1 p
	if c == 0 goto strlen_loop_end
	len += 1
	goto strlen_loop
	:strlen_loop_end
	return len

:putc
function
	argument c
	local p
	p = &c
	syscall(1, 1, p, 1)
	return

:puts
function
	argument s
	local len
	len = strlen(s)
	syscall(1, 1, s, len)
	return

:main
function
	puts(str_hello_world)
	syscall(0x3c, 0)
:str_hello_world
string Hello, world!
byte 10
byte 0

:f
function
	argument x
	argument y
	local v
	local p
	v = *4x
	p = *8y
	*4p = v
	if v == 0 goto something
	*1p = v + 1
	v = *2p
	return v
	:something
	v = *4p
	return v

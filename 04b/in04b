; declaration:
;     global <name>
;     local <name>
;     argument <name>
;     :<label>
; statement:
;     <declaration>
;     if <term> <==/</>/>=/<=/!=> <term> goto <label>   NOTE: this uses signed comparisons
;     goto <label>
;     <lvalue> = <rvalue>
;     <lvalue> += <rvalue>
;     <lvalue> -= <rvalue>
;     <function>(<term>, <term>, ...)
;     return <rvalue>
;     string <str>
;     byte <number>
; term:
;     <var>
;     .<label>
;     <number>
; number:
;     'c
;     12345
;     0xabc
; lvalue:
;     <var>
;     *1<var> / *2<var> / *4<var> / *8<var>
; rvalue:
;     <term>
;     &<var>
;     *1<var> / *2<var> / *4<var> / *8<var>
;     ~<term>
;     <function>(<term>, <term>, ...)
;     <term> + <term>
;     <term> - <term>
;    NOTE: *, /, % are signed (imul and idiv)
;     <term> * <term>
;     <term> / <term>
;     <term> % <term>
;     <term> & <term>
;     <term> | <term>
;     <term> ^ <term>
;     <term> < <term>  (left shift)
;     <term> > <term>  (unsigned right shift)

syscall(1, 1, .str_hw, 14)
syscall(0x3c, 42)

:str_hw
	string Hello, world!
	byte 10
	
	

:syscall
function
	; I've done some testing, and this should be okay even if
	; rbp-56 goes beyond the end of the stack.
	; mov rax, [rbp-16]
	byte 0x48
	byte 0x8b
	byte 0x85
	byte 0xf0
	byte 0xff
	byte 0xff
	byte 0xff
	; mov rdi, rax
	byte 0x48
	byte 0x89
	byte 0xc7
	
	; mov rax, [rbp-24]
	byte 0x48
	byte 0x8b
	byte 0x85
	byte 0xe8
	byte 0xff
	byte 0xff
	byte 0xff
	; mov rsi, rax
	byte 0x48
	byte 0x89
	byte 0xc6
	
	; mov rax, [rbp-32]
	byte 0x48
	byte 0x8b
	byte 0x85
	byte 0xe0
	byte 0xff
	byte 0xff
	byte 0xff
	; mov rdx, rax
	byte 0x48
	byte 0x89
	byte 0xc2
	
	; mov rax, [rbp-40]
	byte 0x48
	byte 0x8b
	byte 0x85
	byte 0xd8
	byte 0xff
	byte 0xff
	byte 0xff
	; mov r10, rax
	byte 0x49
	byte 0x89
	byte 0xc2
	
	; mov rax, [rbp-48]
	byte 0x48
	byte 0x8b
	byte 0x85
	byte 0xd0
	byte 0xff
	byte 0xff
	byte 0xff
	; mov r8, rax
	byte 0x49
	byte 0x89
	byte 0xc0
	
	; mov rax, [rbp-56]
	byte 0x48
	byte 0x8b
	byte 0x85
	byte 0xc8
	byte 0xff
	byte 0xff
	byte 0xff
	; mov r9, rax
	byte 0x49
	byte 0x89
	byte 0xc1
	
	; mov rax, [rbp-8]
	byte 0x48
	byte 0x8b
	byte 0x85
	byte 0xf8
	byte 0xff
	byte 0xff
	byte 0xff
	
	; syscall
	byte 0x0f
	byte 0x05
	
	return
	
global x
global y ;123
global z
:test
function
	local eee
	local fff
	local ggg
	return test2(eee, 0x223, ggg)
	
:test2
function
	return -123
	

:strlen
function
	argument s
	local len
	local c
	local p
	len = 0
	:strlen_loop
	p = s + len
	c = *1 p
	if c == 0 goto strlen_loop_end
	len += 1
	goto strlen_loop
	:strlen_loop_end
	return len

:putc
function
	argument c
	local p
	p = &c
	syscall(1, 1, p, 1)
	return

:puts
function
	argument s
	local len
	len = strlen(s)
	syscall(1, 1, s, len)
	return

:main
function
	puts(.str_hello_world)
	syscall(0x3c, 0)
:str_hello_world
string Hello, world!
byte 10
byte 0

:f
function
	argument x
	argument y
	local v
	local p
	v = *4x
	p = *8y
	*4p = v
	if v == 0 goto something
	*1p = v + 1
	v = *2p
	return v
	:something
	v = *4p
	return v

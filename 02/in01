|| ELF Header
;jm;cd;cd;cd;cd  jump to start of first pass
;'i;'n;'0;'2;00   (0x40007d) input filename
;'o;'u;'t;'0;'2;00  (0x400082) output filename
;00;00;' ;'n;'o;'t;' ;'r;'e;'c;'o;'g;'n;'i;'z;'e;'d;\n;00;00;00;00;00;00 (0x400088) error message/where we read to
;00 (0x4000a0) stores which pass we're on (1 for second pass)
;00;00;00;00;00;00;00 
;00;00;00;00;00;00;00;00 (0x4000a8) used for output
unused padding
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00

-- code starts here

;im;7d;00;40;00;00;00;00;00 pointer to input filename
;JA
;zA O_RDONLY
;IA
;im;02;00;00;00;00;00;00;00 open
;sy

;im;82;00;40;00;00;00;00;00 pointer to output filename
;JA
;im;41;02;00;00;00;00;00;00 O_WRONLY | O_CREAT | O_TRUNC
;IA
;im;ed;01;00;00;00;00;00;00 0o755
;DA
;im;02;00;00;00;00;00;00;00 open
;sy


begin by writing the elf header.
the segment we're loading in includes the ELF header at address 0x400000, so we can just read it from there
;im;04;00;00;00;00;00;00;00 out fd
;JA
;im;00;00;40;00;00;00;00;00 pointer to ELF header
;IA
;im;78;00;00;00;00;00;00;00 length of ELF header
;DA
;im;01;00;00;00;00;00;00;00 write
;sy

-- read command --
;im;03;00;00;00;00;00;00;00 input file descriptor
;JA
;im;88;00;40;00;00;00;00;00 where to read to
;IA
;im;02;00;00;00;00;00;00;00 read 2 bytes
;DA
;zA  read
;sy

;BA
;im;02;00;00;00;00;00;00;00
;cm;jn;cd;cd;cd;cd     end of file

look at first byte of command
;im;88;00;40;00;00;00;00;00
;BA
;zA;lb
;<I;0a      we want the offset, not the index, so we're left shifting by 7+3 = 10
;DA

look at second byte of command
;im;89;00;40;00;00;00;00;00
;BA
;zA;lb
;<I;03     each entry is 8 bytes, so left shift by 3
;BD
;|B

;BA
rbx now contains the command offset
;im;d0;e9;00;00;00;00;00;00    ':' << 10 | ':' << 3
;cm;jn;cd;cd;cd;cd

it's a label definition
read the label name:
;im;03;00;00;00;00;00;00;00 input fd
;JA
;im;88;00;40;00;00;00;00;00
;IA
;im;02;00;00;00;00;00;00;00   2 bytes
;DA
;zA   read
;sy

now call lseek to figure out where in the file we are
;im;04;00;00;00;00;00;00;00 fd (of output)
;JA
;zA;IA  offset = 0
;im;01;00;00;00;00;00;00;00 1 = SEEK_CUR (stay in current location)
;DA
;im;08;00;00;00;00;00;00;00 lseek
;sy
file offset now in rax

;BA
;im;00;00;40;00;00;00;00;00  address of start of file
;+B
address now in rax
;CA store it away in rcx

look at first byte of label
;im;88;00;40;00;00;00;00;00
;BA
;zA;lb
;<I;09 shift left by 9 instead of 7 since each entry takes up 4 bytes
;DA

look at second byte of label
;im;89;00;40;00;00;00;00;00
;BA
;zA;lb
;<I;02 each entry takes up 4 bytes
;BD
;|B


find location in label table
;BA
;im;cd;cd;cd;cd;cd;cd;cd;cd
;+B
;BA
;AC
;sd  store the address there

;jm;cd;cd;cd;cd  skip to newline

unused padding
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00


it's not a label definition. let's check if it's a number
;im;18;8d;00;00;00;00;00;00  '#' << 10 | '#' << 3
;cm;jn;cd;cd;cd;cd

it's a hex number
let's read it one byte at a time, storing the full number in RBP

;zA;RA

;im;03;00;00;00;00;00;00;00
;JA
;im;88;00;40;00;00;00;00;00
;IA
;im;01;00;00;00;00;00;00;00  1 byte
;DA
;zA   read
;sy

;im;88;00;40;00;00;00;00;00
;zA;lb
;BA
;im;30;00;00;00;00;00;00;00
;cm;jl;cd;cd;cd;cd   not 0-9
;im;39;00;00;00;00;00;00;00
;cm;jg;cd;cd;cd;cd   not 0-9

okay it's 0-9
;im;d0;ff;ff;ff;ff;ff;ff;ff
;jm;cd;cd;cd;cd

;00;00;00;00;00;00;00;00;00;00;00;00  padding

;im;61;00;00;00;00;00;00;00
;cm;jl;cd;cd;cd;cd  not a-f--end loop
;im;66;00;00;00;00;00;00;00
;cm;jg;cd;cd;cd;cd  not a-f--end loop

;im;a9;ff;ff;ff;ff;ff;ff;ff

;+B
okay we now have a digit in RBX
;AR
;<I;04
;+B
;RA    store away in RBP
;jm;cd;cd;cd;cd  continue loop

unused padding
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00

okay we have a full number in RBP, time to write it to the file
start by putting it at address 0x4000a8
;im;a8;00;40;00;00;00;00;00
;BA
;AR
;sq

now write

;im;04;00;00;00;00;00;00;00 output file descriptor
;JA
;im;a8;00;40;00;00;00;00;00 address to write from
;IA
;im;08;00;00;00;00;00;00;00 write 8 bytes
;DA
;im;01;00;00;00;00;00;00;00  write
;sy

;jm;cd;cd;cd;cd skip to newline

unused padding
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00

it's not an immediate. let's check if it's a label
;im;68;b5;00;00;00;00;00;00  '-' << 10 | '-' << 3
;cm;jn;cd;cd;cd;cd

absolute label

it's a label
read the label name.

;im;03;00;00;00;00;00;00;00
;JA
;im;88;00;40;00;00;00;00;00
;IA
;im;02;00;00;00;00;00;00;00
;DA
;zA
;sy

convert bytes to an offset
;im;88;00;40;00;00;00;00;00
;BA
;zA;lb
;<I;09;CA

;im;89;00;40;00;00;00;00;00
;BA
;zA;lb
;<I;02
;BC
;|B
;BA
offset in rbx

look in the label table
;im;cd;cd;cd;cd;cd;cd;cd;cd
;+B
;BA
;lq
rax has the address to write.
we can just store it in rbp:
;RA
then jump to the place where we wrote immediates.
;jm;cd;cd;cd;cd

unused padding
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00

;im;68;e9;00;00;00;00;00;00  ':' << 10 | '-' << 3
;cm;jn;cd;cd;cd;cd

relative label

get current file offset
;im;04;00;00;00;00;00;00;00 fd (of output)
;JA
;zA;IA  offset = 0
;im;01;00;00;00;00;00;00;00 1 = SEEK_CUR (stay in current location)
;DA
;im;08;00;00;00;00;00;00;00 lseek
;sy

;BA
;im;04;00;40;00;00;00;00;00
;+B    add 0x400004 to file offset to get address after writing relative address
;RA   store away in rbp

read the label name.
;im;03;00;00;00;00;00;00;00
;JA
;im;88;00;40;00;00;00;00;00
;IA
;im;02;00;00;00;00;00;00;00
;DA
;zA
;sy

convert bytes to an offset
;im;88;00;40;00;00;00;00;00
;BA
;zA;lb
;<I;09;CA

;im;89;00;40;00;00;00;00;00
;BA
;zA;lb
;<I;02
;BC
;|B
;BA
offset in rbx

look in the label table
;im;cd;cd;cd;cd;cd;cd;cd;cd
;+B
;BA
;lq
;BA
subtract current address
;AR
;nA;+B 

now we want to write eax to the output file.
start by putting it at address 0x4000a8
;im;a8;00;40;00;00;00;00;00
;BA
;AR
;sd

now write
;im;04;00;00;00;00;00;00;00 output file descriptor
;JA
;im;a8;00;40;00;00;00;00;00 address to write from
;IA
;im;04;00;00;00;00;00;00;00 4 bytes
;DA
;im;01;00;00;00;00;00;00;00  write
;sy

;jm;cd;cd;cd;cd skip to newline

unused padding
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00



it's not a label or a number. let's look it up in the instruction table.
;im;cd;cd;cd;cd;cd;cd;cd;cd   start of instruction table
;+B
;BA
;zA;lb
;DA    number of bytes to write (used for syscall if no error)
;BA
;zA
;cm;jn;cd;cd;cd;cd check if # of bytes is 0, if not, skip outputting error

bad command!
;im;02;00;00;00;00;00;00;00 stderr
;JA
;im;88;00;40;00;00;00;00;00 address to write from
;IA
;im;12;00;00;00;00;00;00;00 write 18 bytes
;DA
;im;01;00;00;00;00;00;00;00 write
;sy
;cc   easy exit (trace trap)

;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00

this is a real command
;im;01;00;00;00;00;00;00;00 add 1 because we don't want to write the length 
;+B
;IA   address of data to write
;im;04;00;00;00;00;00;00;00  out file descriptor
;JA
;im;01;00;00;00;00;00;00;00 write
;sy

-- skip to newline --

;im;03;00;00;00;00;00;00;00 in fd
;JA
;im;88;00;40;00;00;00;00;00
;IA
;im;01;00;00;00;00;00;00;00 read 1 byte
;DA
;zA
;sy

;im;88;00;40;00;00;00;00;00
;BA
;zA;lb
;BA
;im;0a;00;00;00;00;00;00;00 '\n'
;cm;jn;cd;cd;cd;cd  not a newline--keep looping
;jm;cd;cd;cd;cd   go back to read next command

unused padding
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00

-- end of file --

lseek input fd back to start of file
;im;03;00;00;00;00;00;00;00
;JA
;zA;IA   0 offset
;DA      0 = SEEK_SET (start of file)
;im;08;00;00;00;00;00;00;00  lseek
;sy

lseek output fd back to start of file
;im;04;00;00;00;00;00;00;00
;JA
;zA;IA   0 offset
;DA      SEEK_SET
;im;08;00;00;00;00;00;00;00  lseek
;sy

check if we're on the second pass
;im;a0;00;40;00;00;00;00;00
;BA
;zA;lb
;DA  okay store that in rdx for a sec

;im;01;00;00;00;00;00;00;00
;sb   set second pass to 1

;BD
;zA
;cm;je;cd;cd;cd;cd   not the second pass, jump back to do it

okay we're done the second pass. let's exit nicely
;zA;JA  exit code 0
;im;3c;00;00;00;00;00;00;00 exit
;sy


unused padding
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00;00
;
